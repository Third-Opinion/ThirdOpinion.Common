name: 'Get Version from GitVersion'
description: 'Determines version using GitVersion with ContinuousDeployment mode (each commit = one patch increment)'

inputs:
  config_file_path:
    description: 'Path to GitVersion config file'
    required: false
    default: '.gitversion.yml'

outputs:
  formatted_version:
    description: 'Formatted version without commit count (e.g., 1.1.11-preview)'
    value: ${{ steps.version.outputs.formatted_version }}
  base_version:
    description: 'Base version without pre-release label (e.g., 1.1.11)'
    value: ${{ steps.version.outputs.base_version }}
  sem_ver:
    description: 'SemVer with commit count (e.g., 1.1.11-preview.108)'
    value: ${{ steps.version.outputs.sem_ver }}
  full_sem_ver:
    description: 'Full SemVer with build metadata'
    value: ${{ steps.version.outputs.full_sem_ver }}
  assembly_sem_ver:
    description: 'Assembly SemVer (for assembly versioning)'
    value: ${{ steps.version.outputs.assembly_sem_ver }}
  assembly_sem_file_ver:
    description: 'Assembly SemFileVer (for file versioning)'
    value: ${{ steps.version.outputs.assembly_sem_file_ver }}
  is_prerelease:
    description: 'Whether this is a pre-release version'
    value: ${{ steps.version.outputs.is_prerelease }}
  branch_name:
    description: 'Current branch name'
    value: ${{ steps.version.outputs.branch_name }}
  major:
    description: 'Major version number'
    value: ${{ steps.version.outputs.major }}
  minor:
    description: 'Minor version number'
    value: ${{ steps.version.outputs.minor }}
  patch:
    description: 'Patch version number'
    value: ${{ steps.version.outputs.patch }}

runs:
  using: 'composite'
  steps:
    - name: Install GitVersion
      uses: gittools/actions/gitversion/setup@v4.2.0
      with:
        versionSpec: '6.4.x'

    - name: Execute GitVersion
      id: gitversion
      uses: gittools/actions/gitversion/execute@v4.2.0
      with:
        configFilePath: ${{ inputs.config_file_path }}

    - name: Format version with commit-based increment
      id: version
      shell: bash
      run: |
        MAJOR="${{ steps.gitversion.outputs.major }}"
        MINOR="${{ steps.gitversion.outputs.minor }}"
        BASE_PATCH="${{ steps.gitversion.outputs.patch }}"
        COMMITS_SINCE_VERSION="${{ steps.gitversion.outputs.commitsSinceVersionSource }}"
        PRE_RELEASE_LABEL="${{ steps.gitversion.outputs.preReleaseLabel }}"
        ORIGINAL_SEMVER="${{ steps.gitversion.outputs.semVer }}"
        BRANCH_NAME="${{ steps.gitversion.outputs.branchName }}"
        
        # Detect if this is a develop or fix branch that should have preview label
        # GitVersion might not always apply the label, so we check the branch name pattern
        IS_PREVIEW_BRANCH=false
        if [[ "$BRANCH_NAME" =~ ^(develop|fix|fixes)[/-] ]] || [[ "$BRANCH_NAME" =~ ^dev(elop)?(ment)?$ ]]; then
          IS_PREVIEW_BRANCH=true
          # Override label if GitVersion didn't set it
          if [ -z "$PRE_RELEASE_LABEL" ]; then
            PRE_RELEASE_LABEL="preview"
          fi
        fi
        
        # For develop/fix branches in ContinuousDeployment mode:
        # Each commit = one patch increment (1.1.11 -> 1.1.12 -> 1.1.13)
        # Workaround: GitVersion counts from last tag (v1.0.0), but we want to count from next-version (1.1.11)
        # Solution: Calculate effective commits since 1.1.11 by finding the commit where .gitversion.yml
        # was first set with next-version: 1.1.11, then count commits from there
        if [ "$IS_PREVIEW_BRANCH" = true ] || ([ -n "$PRE_RELEASE_LABEL" ] && [ "$PRE_RELEASE_LABEL" = "preview" ]); then
          # ContinuousDeployment: Each commit increments patch by 1
          # Find the commit where .gitversion.yml was first set with next-version: 1.1.11
          # Then count commits from that point
          
          # Find the first commit that added/modified .gitversion.yml with next-version: 1.1.11
          # This is our "base" commit for counting
          GITVERSION_BASE_COMMIT=$(git log --all --reverse --format="%H" -- .gitversion.yml 2>/dev/null | head -1 || echo "")
          
          if [ -n "$GITVERSION_BASE_COMMIT" ]; then
            # Count commits since .gitversion.yml was first created/modified
            COMMITS_SINCE_GITVERSION=$(git rev-list --count "$GITVERSION_BASE_COMMIT"..HEAD 2>/dev/null || echo "0")
            
            # If we have commits since gitversion.yml was set, use that count
            # Otherwise, we're at the base commit, so use base + 1
            if [ "$COMMITS_SINCE_GITVERSION" -gt 0 ]; then
              CALCULATED_PATCH=$((BASE_PATCH + COMMITS_SINCE_GITVERSION))
              echo "   ℹ️  Counting from .gitversion.yml base: $COMMITS_SINCE_GITVERSION commits since setup"
            else
              # At the base commit, use base + 1
              CALCULATED_PATCH=$((BASE_PATCH + 1))
              echo "   ℹ️  At base commit, using base + 1"
            fi
          else
            # Fallback: If we can't find .gitversion.yml in history, use heuristic
            # If CommitsSinceVersionSource is very large (counting from old tag v1.0.0),
            # normalize by using base + 1 for the first calculation
            if [ "$COMMITS_SINCE_VERSION" -gt 50 ] && [ "$BASE_PATCH" -eq 11 ]; then
              CALCULATED_PATCH=$((BASE_PATCH + 1))
              echo "   ⚠️  Using normalized calculation (next-version: 1.1.11). Tag v1.1.11 for accurate counting."
            else
              # Normal case: use commits since version source
              CALCULATED_PATCH=$((BASE_PATCH + COMMITS_SINCE_VERSION))
            fi
          fi
          
          MAJOR_MINOR_PATCH="${MAJOR}.${MINOR}.${CALCULATED_PATCH}"
          FORMATTED_VERSION="${MAJOR_MINOR_PATCH}-preview"
          BASE_VERSION="${MAJOR}.${MINOR}.${BASE_PATCH}"
        else
          # For stable branches (main/master) or other labels, use GitVersion's calculation
          MAJOR_MINOR_PATCH="${{ steps.gitversion.outputs.majorMinorPatch }}"
          BASE_VERSION="$MAJOR_MINOR_PATCH"
          CALCULATED_PATCH="$BASE_PATCH"
          if [ -n "$PRE_RELEASE_LABEL" ]; then
            FORMATTED_VERSION="${MAJOR_MINOR_PATCH}-${PRE_RELEASE_LABEL}"
          else
            FORMATTED_VERSION="$MAJOR_MINOR_PATCH"
          fi
        fi
        
        echo "formatted_version=$FORMATTED_VERSION" >> $GITHUB_OUTPUT
        echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
        echo "sem_ver=$ORIGINAL_SEMVER" >> $GITHUB_OUTPUT
        echo "full_sem_ver=${{ steps.gitversion.outputs.fullSemVer }}" >> $GITHUB_OUTPUT
        echo "assembly_sem_ver=${{ steps.gitversion.outputs.assemblySemVer }}" >> $GITHUB_OUTPUT
        echo "assembly_sem_file_ver=${{ steps.gitversion.outputs.assemblySemFileVer }}" >> $GITHUB_OUTPUT
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        echo "major=$MAJOR" >> $GITHUB_OUTPUT
        echo "minor=$MINOR" >> $GITHUB_OUTPUT
        echo "patch=$CALCULATED_PATCH" >> $GITHUB_OUTPUT
        
        # Check if it's a pre-release
        if [ "$IS_PREVIEW_BRANCH" = true ] || [ -n "$PRE_RELEASE_LABEL" ]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
        
        echo "✅ Calculated version: $FORMATTED_VERSION"
        echo "   Base version: $BASE_VERSION"
        echo "   Branch: $BRANCH_NAME"
        if [ "$IS_PREVIEW_BRANCH" = true ] || ([ -n "$PRE_RELEASE_LABEL" ] && [ "$PRE_RELEASE_LABEL" = "preview" ]); then
          echo "   ContinuousDeployment mode: Each commit = +1 patch"
          echo "   Commits since version source: $COMMITS_SINCE_VERSION"
          echo "   Patch calculation: $BASE_PATCH + $COMMITS_SINCE_VERSION = $CALCULATED_PATCH"
          echo "   (Preview branch detected: $BRANCH_NAME)"
        fi
        echo "   Original SemVer: $ORIGINAL_SEMVER"

